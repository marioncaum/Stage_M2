\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage[babel=true]{csquotes}
\usepackage{color} 
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{float}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{pgfgantt}

\definecolor{linkcolor}{rgb}{0,0,0.3}

\hypersetup{colorlinks,
            citecolor = linkcolor,
            filecolor = linkcolor,
            linkcolor = linkcolor,
            urlcolor = linkcolor}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{theorem}{Théorème}
\newtheorem{lemma}{Lemme}
\newtheorem{prop}{Propriété}
\newtheorem{exemple}{Exemple}

\titleformat{\part}
  {\normalfont\LARGE\bfseries}{\thepart}{1em}{}
\titlespacing*{\part}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\newcommand\mycom[2]{\genfrac{}{}{0pt}{}{#1}{#2}}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\lstset{backgroundcolor=\color{white},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Python,
  morekeywords={*,...},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=5,
  stringstyle=\color{mymauve},
  tabsize=4,
  title=\lstname 
}

%\usepackage{amsfonts}
%\usepackage{lilyglyphs}
%\usepackage{stmaryrd}
%\usepackage{makeidx}
%\makeindex
%\usepackage[english, onelanguage]{algorithm2e}
%\theoremstyle{plain} \newtheorem{prop}{Proposition}

\title{\vspace{20mm}
        \LARGE \textbf {Ordonnancement et équité}\\
        \vspace{8mm}
        \large \textbf{Rapport de stage}\\
        \vspace{10mm}
        \begin{center}
            \includegraphics[scale = 1]{main_title.jpg}
        \end{center}
        \author{Marion Caumartin}
        \large {Master d'informatique M2}\\
          \vspace{5mm}
        \large {Faculté de Sciences et Ingénieurie de Sorbonne Université \vspace{15mm}}\\ 
        \date{\vspace{10mm} \textsf{\textrm{\textit{6 mars 2019}}}}}



\begin{document}

\maketitle
\thispagestyle{empty}

\newpage

\tableofcontents
\thispagestyle{empty}

\newpage
\setcounter{page}{1}
\section{Introduction}\label{intro}
\noindent
Les problèmes d'ordonnancement constituent un domaine important en recherche opérationnelle. Ils traitent de l'affectation de tâches à des machines, et de l'exécution de ces tâches au cours du temps : il s'agit de savoir où - sur quelle machine - et quand commencera chaque tâche. Récemment, des problèmes d'ordonnancement en présence de différents acteurs ont été étudiés. Cependant, très peu de critères d'équité ont été appliqués aux problèmes d'ordonnancement (hormis le critère classique qui consiste à minimiser le coût maximal d'une machine).\\\\
La théorie du partage équitable est un domaine central en choix social computationnel. Elle s'intéresse à définir des règles d'affectation de ressources à des agents de manière à satisfaire au mieux les agents, sachant que les préférences de ceux-ci peuvent avoir différentes structures inhérentes au problème. Un concept fréquemment utilisé pour évaluer les affectations est celui de l'absence d'envie (envy freeness) : une affectation de ressources est dite sans-envie si aucun des agents ne préfère le lot de ressources d'un autre agent à son propre lot.\\\\
Le but de ce stage est d'appliquer des concepts et techniques développés en théorie du partage équitable, au domaine de l'ordonnancement. On cherche ainsi à évaluer la qualité des ordonnancements du point de vue de l'équité et à calculer des ordonnancements "équitables".

\newpage

\section{Définition du problème}\label{def_pb}

\subsection{Ordonnancement}\label{ordo}

\noindent
On note $m$ le nombre de machines.\\\\
On note $s_i^j$ le slot de temps $i$ de la machine $j$.\\\\
$\lbrace 1,\dots , n \rbrace$ un ensemble d'agents.\\\\
Chaque agent $k$ a un ensemble de $x \in \mathbb{N}$ tâches à réaliser et un critère $f_k$ à minimiser.\\\\
On note $J_i^k$ la tâche $i$ de l'agent $k$.\\\\
Chaque tâche $J_i^k$ a une durée $p_i^k$, peut avoir une deadline $d_i^k$ et une date de disponibilité $r_i^k$.\\\\
Dans un premier temps, on considère que $\forall k \in \lbrace 1, \dots , n \rbrace, \forall i \in \lbrace 1, \dots , x \rbrace, p_i^k = 1$.\\\\
Un ordonnancement $\sigma$ est définit par les dates de début des tâches : $\sigma(J_i^k)$. On note $\mathscr{S}$ l'ensemble des ordonnancements valides. On note $\sigma(k)$ l'ordonnancement de l'agent $k$ pour l'ordonnancement $\sigma$.\\\\
On note $C_i^k$ la date de fin de la tâche $i$ de l'agent $k$ : $C_i^k = \sigma(J_i^k) + p_i^k$.\\\\
$C_{max}^k = \max\limits_i C_i^k$ : date de fin maximum (makespan)\\\\
$T_i^k = \max(0, C_i^k - d_i^k)$ : retard\\\\
$L_i^k = C_i^k - d_i^k$ : retard algébrique\\\\
$U_i^k = \left\{
\begin{array}{l}
  1 \ \mathrm{si} \ C_i^k>d_i^k \\
  0 \ \mathrm{sinon}
\end{array}
\right.$ : vaut 1 si $J_i^k$ est en retard, 0 sinon\\\\
$E_i^k = \max (0, d_i^k - C_i^k)$ : avance\\\\
$S_i^k = (L_i^k)^2$\\\\
$D_i^k = |D_i^k|$

\newpage

\subsection{Equité}\label{equite}
\subsubsection{Définition}
\noindent
On cherche un ordonnancement où chaque agent a exactement $x$ slot : $\forall k \in \lbrace 1, \dots , n \rbrace, |\sigma(k)| = x$.\\\\
$\forall k, k' \lbrace 1, \dots , n \rbrace, \sigma(k)\cap\sigma(k') = \emptyset$.\\\\
Les slots ne peuvent pas être divisés.\\\\
On note $f = (f_1, \dots, f_n)$.\\\\
Pareto-optimalité : $\sigma$ domine $\sigma'$ au sens de Pareto ssi \\
$\left\{
\begin{array}{l}
  \forall k \in \lbrace1, \dots,n\rbrace,f_k(\sigma(k))\leq f_k(\sigma'(k)) \\
  \exists k \in \lbrace1, \dots,n\rbrace,f_k(\sigma(k))< f_k(\sigma'(k))
\end{array}
\right.$\\\\
utilitarian social welfare : minimiser $\sum\limits_{k = 1}^n f_k$.\\\\
egalitarian social welfare : minimiser $\max\limits_{k = 1}^n f_k$.\\\\
leximin : $\sigma \succ_{lex}\sigma' \iff \exists i\in \lbrace1, \dots,n-1\rbrace,
\left\{
\begin{array}{l}
  \forall k < i ,f_k(\sigma(k)) = f_k(\sigma'(k))\\
  f_i(\sigma(i)) < f_i(\sigma'(i))
\end{array}
\right.$\\\\
proportional fair share : on note $f_k^*$ le coût si $k$ disposait des machines pour lui seul.\\ pfs($k$) $ = nf_k^*$.\\\\
maxmin fair share : mfs($k$) $= \min\limits_{\sigma\in\mathscr{S}}\max\limits_{i=1}^n f_k(\sigma(i))$.\\\\
Ordonnancement sans envie : $\forall k,j\in \lbrace1, \dots,n\rbrace, f_k(\sigma(k))\leq f_k(\sigma(j))$\\\\
Envie entre deux agents : $e_{ij} = \max(0, f_i(\sigma(i)) - f_i(\sigma(j)))$\\\\
degré d'envie : $e_i = \max\limits_j e_{ij}$ ou $e_i = \sum\limits_j e_{ij}$\\\\
envie de la société : $\max\limits_i e_i$ ou $\sum\limits_i e_i$\\\\
Envie up to one slot : $i$ envie $j$ up to one slot ssi $\exists s\in \sigma(i), f_i(\sigma(i)\backslash s)\leq f_i(\sigma(j))$\\\\
Envie up to any slot : $i$ envie $j$ up to any slot ssi $\forall s\in \sigma(i), f_i(\sigma(i)\backslash s)\leq f_i(\sigma(j))$\\\\

\subsubsection{Propriétés}
\begin{prop}
    Au moins un ordonnancement egalitarian-optimal est Pareto-optimal.
\end{prop}

\begin{proof}
    Par l'absurde :\\
    Soit $\sigma$ un ordonnancement egalitarian-optimal. Supposons que $\sigma$ n'est pas Pareto-optimal. Il existe donc un ordonnancement $\sigma'$ Pareto-optimal qui domine $\sigma$ et qui n'est pa egalitarian-optimal.\\
    2 cas possibles : 
    \begin{itemize}
        \item $\max_{i = 1}^n f_i(\sigma'(i)) = \max_{i = 1}^n f_i(\sigma(i))$ : comme $\sigma$ est egalitarian-optimal, alors $\sigma'$ l'est aussi $\implies$ contradiction.
        \item $\max_{i = 1}^n f_i(\sigma'(i)) \leq \max_{i = 1}^n f_i(\sigma(i))$ : donc $\sigma$ n'est pas egalitarian-optimal $\implies$ contradiction.
    \end{itemize}
\end{proof}

\begin{prop}
    Un ordonnancement sans envie n'est pas toujours Pareto-optimal.
\end{prop}
\begin{exemple}
    On considère une instance avec une machine et deux agents $A$ et $B$ qui veulent optimiser le même critère. Chaque agent a deux tâches à exécuter sur la machine. On note $A_i$ (reps. $B_i$) la tâche $i$ de l'agent $A$ (resp. $B$) pour $i \in \lbrace 1,2\rbrace$. Chaque tâche a une deadline : $d_1^A = 1$, $d_2^A = 3$, $d_1^B = 2$ et $d_2^B = 4$.\\
    On appelle $\sigma_1$ l'ordonnancement suivant :
    \begin{ganttchart}[inline]{1}{8}
        \ganttbar{$A_1$}{1}{2} 
        \ganttbar{$B_1$}{3}{4} 
        \ganttbar{$B_2$}{5}{6} 
        \ganttbar{$A_2$}{7}{8}
    \end{ganttchart}\\
    On appelle $\sigma_2$ l'ordonnancement suivant :
    \begin{ganttchart}[inline]{1}{8}
        \ganttbar{$A_1$}{1}{2} 
        \ganttbar{$B_1$}{3}{4} 
        \ganttbar{$A_2$}{5}{6} 
        \ganttbar{$B_2$}{7}{8}
    \end{ganttchart}
    
    
\end{exemple}




\end{document}